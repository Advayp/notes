## Formats for Encoding Data
- Two main ones:
	- In memory: objects, structs, etc.
	- In a file or when sending through a network: some standardized sequence of bytes
- Going from in-memory to encoded is called marshalling, serialization, or encoding
- Going from encoded to in-memory is called unmarshalling, deserialization, or decoding
- Languages have built-in support for serialization and deserialization, but these don't interop well with other frameworks for other languages
- Problems with JSON, XML, and CSV formats
	- Encoding numbers comes with a lot of ambiguity. XML and CSV don't differentiate between a number and a string, and JSON doesn't distinguish between integers and floats
	- Precision is also undefined and unstandardized across each of the formats
	- CSV doesn't have any schema (XML has one that's used frequently), so data received depends a lot on the application
		- Pretty vague format too
	- Despite these concerns, these formats are still pretty good


## Thrift and Protocol Buffers
- Require a schema for any data that needs to be encoded
- Provide code generation tools that create classes/interfaces for the programming language you're working with
- Both of these encode data in field tags instead of field names
	- Takes less space, since field names are usually strings
- Schema evolution:
	- Use new field tags. This way, old code can read request generated by new code. If you don't change the field tags, you'll end up with conflicts since the old code will expect a certain datatype different from that provided by the request generated by the new code


## Modes of Dataflow


### Dataflow through Databases
- Forward and backward compatibility are important, as the various applications could have different versions of code than the database engine
- Different values written at different times
	- Data outlives code
	- Migrations are possible, but expensive for large datasets. 

### Dataflow Through Services: REST and RPC
- Microservices: large application is deconstructed into several smaller services
- Microservices:
	- Each service should be managed by a dedicated team
	- Team should release new versions frequently without coordinating with other teams
		- While maintaining backward compatibility 
- REST
	- Design philosophy
	- Uses URLs for identifying resources and HTTP features for cache control, authentication, and content type negotiation
	- Associated with microservices