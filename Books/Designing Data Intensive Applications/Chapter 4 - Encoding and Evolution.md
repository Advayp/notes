## Formats for Encoding Data
- Two main ones:
	- In memory: objects, structs, etc.
	- In a file or when sending through a network: some standardized sequence of bytes
- Going from in-memory to encoded is called marshalling, serialization, or encoding
- Going from encoded to in-memory is called unmarshalling, deserialization, or decoding
- Languages have built-in support for serialization and deserialization, but these don't interop well with other frameworks for other languages
- Problems with JSON, XML, and CSV formats
	- Encoding numbers comes with a lot of ambiguity. XML and CSV don't differentiate between a number and a string, and JSON doesn't distinguish between integers and floats
	- Precision is also undefined and unstandardized across each of the formats
	- CSV doesn't have any schema (XML has one that's used frequently), so data received depends a lot on the application
		- Pretty vague format too
	- Despite these concerns, these formats are still pretty good


## Thrift and Protocol Buffers
- Require a schema for any data that needs to be encoded
- Provide code generation tools that create classes/interfaces for the programming language you're working with
- Both of these encode data in field tags instead of field names
	- Takes less space, since field names are usually strings
- Schema evolution:
	- Use new field tags. This way, old code can read request generated by new code. If you don't change the field tags, you'll end up with conflicts since the old code will expect a certain datatype different from that provided by the request generated by the new code


## Modes of Dataflow


### Dataflow through Databases
- Forward and backward compatibility are important, as the various applications could have different versions of code than the database engine
- Different values written at different times
	- Data outlives code
	- Migrations are possible, but expensive for large datasets. 

### Dataflow Through Services: REST and RPC
- Microservices: large application is deconstructed into several smaller services
- Microservices:
	- Each service should be managed by a dedicated team
	- Team should release new versions frequently without coordinating with other teams
		- While maintaining backward compatibility 
- REST
	- Design philosophy
	- Uses URLs for identifying resources and HTTP features for cache control, authentication, and content type negotiation
	- Associated with microservices
- RPC (remote procedural calls)
	- Makes a network request look the same as calling a function or method in your programming language
	- Few problems with this though
		- A function call should be predictable and ideally behave completely under your control. RPC doesn't follow this philosophy, as issues can arise from network errors
		- There's less clarity around why an RPC fails, whether that's because of a timeout or some other network issue -- harder to debug
		- Latency and execution time of RPC varies greatly
		- Serialization is a hard requirement, can become complicated with more complex objects
			- This can also result in a mismatch between types

## Message-Passing Dataflow
- Async message-passing systems: lie in between RPC and databases systems
	- Similar to RPC: request (called a message) is delivered with low-latency to some handler
	- Similar to databases: Message is sent via an intermediary called a message broker
- Advantages:
	- Acts as a buffer, improving reliability
	- Can adjust target based on crashes, ensuring messages are still delivered
	- Doesn't require sender to know IP address
	- One message can be sent to multiple recipients
	- Decouples sender from recipient
- Main workflow with message brokers:
	- Sender sends a message to a named queue or topic
	- The broker delivers that message to all the subscribers of that queue/topic
	- Messages don't use any format in particular, so they're flexible in this sense

## Distributed Actor Frameworks
- Manages concurrency in a single process - encapsulates everything in an actor
- Each actor has local state. Message delivery isn't guaranteed either.
- Distributed actor frameworks can scale better across multiple nodes
	- Integrates a message broker and the actor programming model into a single framework